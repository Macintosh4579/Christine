#!/usr/bin/env python

# -*- coding: UTF8 -*-
#
# Copyright (c) Marco Antonio Islas Cruz
# <markuz@islascruz.org>

import os,gtk,gobject
import cPickle as pickle
import gst
import gst.play
import gst.interfaces

wdir = os.environ["HOME"]+"/.christine/"
sound = ["mp3","ogg","wma"]
video = ["mpg","mpeg","mpe","ogg","avi"]

class sanity:
	'''
		Make all the sanity checks
	'''
	def __init__(self):
		self.__check_christine_dir()

	def __check_christine_dir(self):
		if not os.path.exists(wdir):
			os.mkdir(wdir)
		else:
			if os.path.isfile(wdir):
				os.unlink(wdir)
				self.__check_christine_dir()


class lib_library:
	def __init__(self,list):
		sanity()
		try:
			f =	open(os.path.join(wdir,list),"r")
			self.files = pickle.load(f)
			f.close()
		except:
			self.files = {}
		self.list = list

	def __setitem__(self,name,path):
		self.append(name,path)
		
	def append(self,name,data):
		if type(data) != type({}):
			raise TypeError, "data must be a dict, got %s"%type(data)
		self.files[name]=data

	def keys(self):
		return self.files.keys()
	
	def save(self):
		f = open(wdir+self.list,"w")
		pickle.dump(self.files,f)
		f.close()

	def clear(self):
		self.files.clear()
	
	def remove(self,key):
		c = {}
		if key in self.keys():
			for i in self.keys():
				if i != key:
					c[i]= self.files[i]
			self.files = c.copy()
			#print "%s removed"%key
			print self.files.keys()
		else:
			#print "key %s not found"%key
			pass
	
	def get_type(self,file):
		ext = file.split(".").pop()
		if ext in sound:
			return "sound"
		if ext in video:
			return "video"
	
	def get_sounds(self):
		a = {}
		for i in self.keys():
			if self.files[i]["type"] == "sound":
				a[i] = self.files[i]
		return a

	def get_videos(self):
		a = {}
		for i in self.keys():
			if self.files[i]["type"] == "video":
				a[i] = self.files[i]
		return a

class player(gtk.DrawingArea):
	def __init__(self,parent):
		gtk.DrawingArea.__init__(self)
		self.main = parent
		self.tags = {}
		self.connect('destroy', self.destroy_cb)
		self.connect('expose-event', self.expose_cb)
		self.set_size_request(200,200)
		#self.play = gst.play.Play()
		self.play = gst.element_factory_make("playbin")
		clock = self.play.get_clock()
		self.play.set_clock(clock)
		#self.play.connect("found-tag",self.found_tag_cb)
		self.play.connect("have-video-size",self.size_request)
		self.play.connect("error",self.error_handler)

		#self.audio_sink = gst.element_factory_make('alsasink')
		self.audio_sink = gst.element_factory_make('esdsink')
		self.audio_sink.connect("found-tag",self.found_tag_cb)
		#self.audio_sink.set_property('device', 'hw:0')

		self.video_sink = gst.element_factory_make("xvimagesink")
		#self.video_sink = gst.element_factory_make("gconfvideosink")
		self.play.set_video_sink(self.video_sink)

		
		#filesrc = gst.element_factory_make("filesrc")
		filesrc = gst.element_factory_make("gnomevfssink")
		self.play.set_data_src(filesrc)
		#self.play.set_audio_sink(self.audio_sink)

		self.visualization = gst.element_factory_make("goom")
		self.play.set_visualization(self.visualization)

		self.volume = gst.element_factory_make("volume")
		self.volume.link(self.audio_sink)
		self.play.set_audio_sink(self.volume)
		#self.play.add(self.volume)
		#print self.play.get_pad_list(),self.play.get_list()
		print self.volume.get_state
		self.volume.set_property("volume",0.0)
		self.volume.set_property("mute",True)

		self.__create_fakeplay()
		t = gobject.timeout_add(500,self.sync,self.audio_sink,self.video_sink)
		
	
	def __create_fakeplay(self):
		self.__fakeplay = gst.play.Play()
		self.__fakeplay.connect("found-tag",self.found_tag_cb)
		self.__fakeplay.set_data_src(gst.element_factory_make("filesrc"))
		self.__fakeplay.set_audio_sink(gst.element_factory_make("fakesink"))
		self.__fakeplay.set_video_sink(gst.element_factory_make("fakesink"))
		
		
	def found_tag_cb(self,play, src, tags):
		if len(tags.keys()) > 0:
			for i in tags.keys():
				self.tags[i] = tags[i]
	
	def sync(self,audio,video):
		self.play.sync_children_state()
		return True
		

	def error_handler(self,a,b,c,d):
		print a,b,c,d,a.get_state()
		print "Hooo., I'm dead.."
		
	def size_request(self,a,b,c):
		self.size = [b,c]
		self.set_size_request(b,c)
		
	
	def set_location(self,filename):
		self.tags = {}
		ext = filename.split(".").pop()
		self.play.set_location(filename)
		self.__fakeplay.set_location(filename)
		self.__fakeplay.set_state(gst.STATE_PLAYING)
		self.__fakeplay.set_state(gst.STATE_PAUSED)
		self.get_type()

	def get_tag(self,key):
		try:
			return self.tags[key]
		except:
			return ""
	
	def get_location(self):
		return self.play.get_location()

	def get_type(self):
		if self.isvideo():
			self.type = "video"
		elif self.issound():
			self.type = "sound"
		else:
			raise TypeError,"Not an known video or sound"
		
	def playit(self):
		self.play.set_state(gst.STATE_PLAYING)
		
	def pause(self,a=None):
		self.play.set_state(gst.STATE_PAUSED)
		
	def stop (self,a=None):
		#self.hide()
		self.play.set_state(gst.STATE_NULL)
		self.main.scale.set_value(0)
	
	def nano2str(self,nanos):
		ts = nanos / gst.SECOND
		return '%02d:%02d:%02d.%06d' % (ts / 3600,
				ts / 60,ts % 60, nanos % gst.SECOND)
		print ts

	def destroy_cb(self, da):
		#self.error_handler("","")
		self.video_sink.set_xwindow_id(0L)
		
	def expose_cb(self, window, event=None):
		self.video_sink.set_xwindow_id(self.window.xid)
	
	def seek_to(self,sec):
		sec = long(sec)*gst.SECOND
		self.audio_sink.seek(gst.FORMAT_TIME|gst.SEEK_FLAG_FLUSH
				|gst.SEEK_METHOD_SET,sec)
		self.video_sink.seek(gst.FORMAT_TIME|gst.SEEK_FLAG_FLUSH
				|gst.SEEK_METHOD_SET,sec)


	def isvideo(self):
		#print "isvideo", self.tags.keys()
		if "video-codec" in self.tags.keys():
			return True
		else:
			return False
		
	def issound(self):
		if not "video-codec" in self.tags.keys():
			return True
		else:
			return False
	

	def gstmain(self):
		gst.main()
		return False

	def quit(self):
		gst.main_quit()



